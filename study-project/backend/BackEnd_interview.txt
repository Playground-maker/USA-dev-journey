
[1세트]
1-1) String / StringBuilder / StringBuffer의 차이점

String은 불변(Immutable) 객체로, 문자열을 수정하면 새로운 객체가 생성됩니다. 따라서 빈번한 문자열 변경이 있을 경우 성능이 저하될 수 있습니다. 
반면 StringBuilder와 StringBuffer는 가변(Mutable) 객체로, 기존 객체에서 문자열을 변경할 수 있어 성능이 뛰어납니다.

차이점으로는 StringBuffer는 synchronized 키워드가 적용되어 Thread-safe하지만, StringBuilder는 Thread-safe하지 않아 단일 스레드 환경에서 더 빠르게 동작합니다. 
따라서 멀티스레드 환경에서는 StringBuffer, 단일 스레드에서는 StringBuilder가 적합합니다.


1-2) thread safe 설명

Thread-safe란 여러 개의 스레드가 동시에 접근해도 데이터의 일관성이 유지되는 것을 의미합니다. 
Thread-safe하지 않으면 여러 스레드가 같은 데이터를 동시에 수정할 때 오류가 발생할 수 있습니다. 
이를 보장하는 방법으로는 synchronized 키워드를 사용하거나, volatile, Atomic 클래스를 활용하는 방법 등이 있습니다.
Synchronized 키워드는 임계 영역에 하나의 스레드만 접근할 수 있게 해서 이 키워드를 사용한 블록 단위로 락의 획득 및 해제가 발생합니다.
블록을 크게 잡으면 성능 저하 문제가 생길 수 있으므로 임계 영역을 최소화해야 합니다.

cf) StringBuffer는 내부적으로 synchronized 처리가 되어 있어 Thread-safe하지만, 동기화 비용으로 인해 성능이 상대적으로 떨어질 수 있습니다.


[2세트]

2-1) OOP의 4가지 특징(추상화, 캡슐화, 상속, 다형성)

추상화: 불필요한 정보를 제거하고 핵심적인 부분만 남기는 개념입니다. 예를 들어 자동차 클래스에서 엔진 내부 구조는 숨기고, 시동 걸기, 가속하기 같은 핵심 기능만 제공하는 것이 추상화입니다.
캡슐화: 데이터와 메서드를 하나의 클래스로 묶고, 외부에서 직접 접근하지 못하도록 보호하는 개념입니다.
상속: 기존 클래스를 확장하여 새로운 클래스를 만드는 개념입니다. 코드 재사용성을 높이고 유지보수를 쉽게 할 수 있습니다.
다형성: 같은 메서드가 다양한 형태로 동작할 수 있는 개념입니다. 오버로딩(같은 이름의 메서드를 매개변수 형태에 따라 다르게 정의)과 오버라이딩(부모 클래스의 메서드를 자식 클래스에서 재정의)으로 구현됩니다. 


2-2) 캡슐화와 은닉화의 차이
캡슐화는 데이터(필드)와 메서드를 하나의 단위로 묶고, 객체 내부의 데이터를 보호하는 개념입니다. 단순히 데이터를 숨기는 것뿐만 아니라 데이터와 관련된 기능을 하나의 클래스 내에 모아두는 것을 의미합니다.
반면, 은닉화는 외부에서 객체의 데이터를 직접 접근하지 못하도록 숨기는 개념입니다. 즉, 은닉화는 캡슐화를 구현하는 방법 중 하나입니다. 



--------------------------------------------------------------
1세트
1-1) 컴파일러와 인터프리터의 차이점을 설명해 주세요.
-> 컴파일러는 전체 소스 코드를 한 번에 기계어로 변환한 후 실행 파일을 생성하는 방식이며, 실행 속도가 빠르지만, 수정할 때마다 다시 컴파일해야 한다.
반면, 인터프리터는 코드를 한 줄씩 읽고 즉시 실행하는 방식으로, 실행 속도는 느리지만 수정이 즉시 반영된다.

1-2 ) 자바의 접근 제어자는 어떤 것들이 있으며, 각각의 특징은 무엇인가요?
-> 자바의 접근 제어자는 public, protected, default(package-private), private가 있다.

public : 모든 클래스에서 접근 가능
protected : 같은 패키지 또는 상속 관계에서 접근 가능
default(package-private) : 같은 패키지 내에서만 접근 가능
private : 해당 클래스 내에서만 접근 가능


2세트

2-1) 오버로딩과 오버라이딩의 차이점은 무엇인가요?
-> 오버로딩은 같은 클래스 내에서 메서드 이름이 같지만, 매개변수의 타입이나 개수를 다르게 정의하는 것을 의미하며, 컴파일 시 결정된다.
반면, 오버라이딩은 상속 관계에서 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것으로, 런타임 시 결정된다.

2-2) 인터페이스와 추상 클래스의 차이점은 무엇인가요?
-> 인터페이스는 모든 메서드가 추상 메서드이며, 다중 구현이 가능하지만 상태(변수)를 가질 수 없다. 
반면, 추상 클래스는 일반 메서드와 추상 메서드를 모두 포함할 수 있으며, 단일 상속만 가능하지만 상태(인스턴스 변수)를 가질 수 있다.

--------------------------------------------------------------

1. 컴파일 과정을 설명하시오
V 1-1. compiler vs interpreter

V 2. String / StringBuilder / StringBuffer의 차이점
V 2.1 thread safe 설명
2.2 자바에서 String이 불변 객체인 이유(내부적 메커니즘)

V 3. 자바의 접근 제어자의 종류와 특징

V 4. OOP의 4가지 특징(추상화, 캡슐화, 상속, 다형성)
V 4.1 캡슐화와 은닉화의 차이
V 4.2 오버로드와 오버라이딩의 차이

5. OOP의 5대 원칙(SOLID)

6. JVM 구조(중요 !)

7. 클래스 / 객체 / 인스턴스의 차이

V 8. interface와 abstract class의 차이점

9. Checked Exception vs Unchecked Exception

10. Call by reference vs Call by value
10-1. 자바는 어디에 해당하는가?



---------------------------------------------------------------
1. 스프링 프레임워크는 왜 생긴 것인가?

2. 스프링 DI란?
2-1. 객체 주입 방식
2-2. 생성자 방식의 이점
2-3. @Autowired, @Resource, @Inject의 차이점


3. Spring mvc life cycle?
3-1. filter와 interceptor의 차이점
---------------------------------------------------------------


1. HashMap vs HashTable vs ConcurrentHashMap 차이점(구현방식, thread 관련...)
1.1 thread safe


2. Java Immutable Object
2.1 Java String이 불변객체인 이유

3. new String()과 ""(리터럴 방식)의 차이에 대해

4. reflection / Java Dynamic Proxy 설명해 보시오

5. 자바의 Garbage Collector는 어떻게 동작하는지
5.1 GC 알고리즘은 무엇이 있는지

6. 제네릭이란 무엇이고 왜 사용하는가
