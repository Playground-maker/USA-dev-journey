1. 자바스크립트의 이벤트 루프가 어떻게 동작하는지 설명하고 마이크로태스크와 매크로태스크의 차이를 구체적으로 설명해주세요.

답변 : 자바스크립트는 싱글스레드 언어이므로 한번에 한개의 작업만 가능하지만 동시성을 위해서 이벤트 루프를 사용한다.
먼저 코드를 실행하면 동기 코드는 콜스택에 쌓이면서 실행되고 비동기 코드는 마이크로태스크 큐와 매크로태스크 큐에 쌓인다.
Promise then 같은 코드는 마이크로태스크 큐에 추가되며 setTimeout, setInterval 같은 코드는 매크로태스크 큐에 추가된다.
코드 내의 동기함수가 모두 실행되면 마이크로태스크 큐에 쌓인 함수들을 우선적으로 실행하며 마이크로태스크큐의 코드들이 모두 실행되면 매크로태스크 하나를 콜스택에 넣어 실행한다.
이 과정을 반복하며 동기코드와 비동기코드의 실행순서를 조율하고 UI 응답성을 유지하는것이 이벤트루프의 역할이다.

1-1. 고부하 상황에서 이벤트 루프가 어떻게 성능 저하를 유발할 수 있는지 설명해주세요.

답변 : 이벤트루프는 마이크로태스크를 우선적으로 처리하는데 마이크로태스크가 너무 많아지면 매크로태스크를 처리가 지연될 수 있다.
이로 인해 UI 업데이트가 늦어지거나 네트워크 응답 처리 지연이 발생할 수 있으므로 마이크로태스크 큐에 너무 많은 작업이 몰리지 않도록 관리하는것이 중요하다.

-------------------

2. React 컴포넌트의 불필요한 재렌더링에 의한 성능저하를 막기 위한 최적화 기법들이 어떻게 동작하는지 자세히 설명해주세요.

답변 : React는 state나 props가 변경될때마다 컴포넌트를 재렌더링 하고 자식 컴포넌트들도 함께 재렌더링 된다는 특성을 가지고 있다.
이로 인해 불필요한 재렌더링이 너무 많이 발생하는 문제가 생길 수 있다.
useMemo를 사용하여 특정값이 변경될때만 함수를 재실행하도록 하여 컴포넌트 재렌더링시 불필요한 재연산을 막을 수 있다.
useCallback을 사용하여 함수의 참조값을 고정하여 함수의 불필요한 재실행을 막을 수 있다.
React.Memo를 활용해 컴포넌트 자체를 메모이제이션 하여 props가 변경되지않으면 재렌더링되지 않도록 할 수 있다.
이러한 최적화 기법들은 의존성 배열 관리가 중요하며 잘못된 의존성 배열 설정은 오히려 성능 저하를 가져올 수 도 있다.

2-1. 대규모 애플리케이션에서 최적화 기법을 사용할때 발생할 수 있는 부작용과 React Profiler 같은 도구로 성능 문제를 어떻게 진단할 수 있는지 설명해주세요.

답변 : 대규모 애플레이케이션에서는 불필요한 최적화가 코드를 복잡하게 만들고 잘못된 의존성 배열 설정으로 성능 저하 문제가 발생할 수 있다.
또한 메모이제이션을 너무 많이 사용하면 메모리 사용량이 증가하여 오히려 성능을 저하시킬 수 있다.
React Profiler 같은 도구를 활용하면 컴포넌트들의 렌더링 시간을 측정하고 재렌더링이 많은 컴포넌트를 파악할 수 있다.
이러한 정보를 토대로 필요한 곳에만 최적화기법을 적용해야 한다.

-------------------

3. Virtual DOM (가상 돔) 이 무엇인지 설명하세요. => 차이점과 장점 설명
    - Virtual DOM은 실제 DOM을 가상으로 표현하여 UI 변경 사항을 효율적으로 반영하기 위해 사용됨.
    - 브라우저에 표현되고 있는 UI에 변경사항이 있을때마다 실제 DOM을 변경하면 성능 부담이 큼.
    - UI등에 연결되지않은 가상DOM을 메모리 내에 유지하여 변경 사항을 비교한 뒤 최소한의 연산으로 실제 DOM을 변경하도록 한다.

3-1. 리액트의 diffing에 대해 설명해주세요.
    • 앞서 말한 Virtual DOM에서 변경사항을 비교하기 위해 리액트에서 사용하는 알고리즘
    - 1. 컴포넌트나 태그가 동일할 경우 그 속성과 내용만을 비교하며 태그 자체가 변경되면 기존 요소를 제거하고 완전히 새로 생성
    - 2. Key를 활용한 요소비교를 통해 여러최적화를 함. 특정 요소의 위치를 추적하기 쉽도록 하여 불필요한 렌더링을 방지하고 자원사용량을 최적화함.
    - 3. Styled-component 같은 css 라이브러리를 활용할때 key를 활용한 diffing 알고리즘이 적극 활용됨.

-------------------

4. CSR(Client-Side Rendering)과 SSR(Server-Side Rendering)의 차이를 설명해주세요.
    • 클라이언트 사이드 렌더링(CSR) : 초기 HTML은 거의 비어있고 JS의 실행 후 UI가 렌더링 된다.
    - 장점 : SPA (Single Page Application) 에서 주로 사용하며 초기 로딩 이후에는 페이지 전환이 빠르다.
    - 단점 : 클라이언트 측에서 JS 실행후 직접 렌더링 하므로 초기로딩이 느릴 수 있고 초기 페이지 정보가 비어있어 검색엔진최적화(SEO)에 불리하다. 모든 코드가 클라이언트 측에 있어 보안에 불리.
    • 서버 사이드 렌더링(SSR) : 서버에서 HTML을 완성하여 클라이언트에 전달한다.
    - 장점 : 페이지 정보가 모두 담긴채로 HTML을 완성하여 전달받으므로 초기 로딩속도가 빠르며 검색엔진최적화(SEO)에 유리하다.
    - 단점 : 서버의 부하가 증가하며 페이지 전환때마다 서버에서 렌더링을 해야함

4-1. Next.js에서 이 렌더링 방식들을 어떤식으로 활용할 수 있나요?
    • Next.js는 CSR, SSR과 함께 SSG(Static Site Generation)도 지원하는 프레임워크 => 여러 렌더링 방식의 장단점을 잘 섞어 활용이 가능하다.
    - CSR : 검색엔진 최적화(SEO)가 중요하지 않고 데이터 변경이 잦은 페이지 (실시간 주식 가격 등) + 서버 부하 감소
    - SSR : 검색엔진 최적화(SEO)가 중요하며 입력값 등에 따라 내용 변경이 필요한경우 (검색 결과 등)
    - SSG : 검색엔진 최적화(SEO)가 중요하며 내용 변경이 크게 필요하지 않은 경우 (블로그, 상품 상세정보 등)